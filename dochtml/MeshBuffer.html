<!DOCTYPE html><html><head><meta charset=utf-8><title>MeshBuffer</title></head><body><h1> MeshBuffer</h1><p><a href='index.html'>Back to documentation index.</a></p><a name='MeshBuffer'></a>
<h3> new MeshBuffer()</h3><p><b>Deprecated: It is planned to render this class obsolete and rely on three.js's BufferGeometry.</b></p>A geometric mesh in the form of buffer objects.
A mesh buffer is made up of one or more <a href="BufferAccessor.html">vertex attribute objects</a>,
and an optional array of vertex indices. Each vertex attribute object contains
the values of one attribute of the mesh, such as positions,
vertex normals, and texture coordinates. A mesh buffer
can store vertices that make up triangles, line segments, or points.<p>
This constructor creates an empty mesh buffer and sets the array
of vertex indices to null and the primitive type to <a href="MeshBuffer.html#MeshBuffer.TRIANGLES">MeshBuffer.TRIANGLES</a>.<p>
The `MeshBuffer` class contains four methods (`fromPositions`,
`fromPositionsNormals`, `fromPositionsUV`, and `fromPositionsNormalsUV`) that let you define a mesh buffer from a predefined array of vertex data. See the documentation for those methods for more information.<p>
The <a href="Meshes.html">`Meshes`</a> class includes several handy methods for creating built-in shapes; those methods return a `MeshBuffer` object that describes the triangles they
are composed of.
<p><b>Instancing</b>
<p>Some 3D rendering pipelines support <i>instancing</i>, which is a technique for rendering multiple versions of a mesh buffer with a single draw call. Instancing involves the use of a second mesh buffer (an <i>instance buffer</i>); rather than holding vertex data, the instance buffer holds <i>instance data</i>, that is, data to be used when rendering each instance of the first mesh buffer. Besides this, however, instance buffers are largely similar to vertex buffers as far as the <code>MeshBuffer</code> class is concerned; any reference to vertices in the documentation applies analogously to instances in instance buffers. However, instance buffers should use the primitive type <code>MeshBuffer.POINTS</code>; it makes little sense to have instance buffers describe triangles or line segments.<h3> Members</h3><ul><li><a href='#MeshBuffer.LINES'>LINES</a><br>Indicates that a mesh buffer contains line segments; the mesh
buffer stores each line segment using two consecutive vertices.<li><a href='#MeshBuffer.POINTS'>POINTS</a><br>Indicates that a mesh buffer contains points; the mesh
buffer stores each point using one vertex.<li><a href='#MeshBuffer.TRIANGLES'>TRIANGLES</a><br>Indicates that a mesh buffer contains triangles; the mesh
buffer stores each triangle using three consecutive vertices.</ul><h3> Methods</h3><ul><li><a href='#MeshBuffer.fromPositions'>fromPositions</a><br>Creates a new mesh buffer with the given array of vertex positions.<li><a href='#MeshBuffer.fromPositionsColors'>fromPositionsColors</a><br>Creates a new mesh buffer with the given array of vertex positions
and vertex colors.<li><a href='#MeshBuffer.fromPositionsNormals'>fromPositionsNormals</a><br>Creates a new mesh buffer with the given array of vertex positions
and vertex normals.<li><a href='#MeshBuffer.fromPositionsNormalsColors'>fromPositionsNormalsColors</a><br>Creates a new mesh buffer with the given array of vertex positions,
vertex normals, and vertex colors.<li><a href='#MeshBuffer.fromPositionsNormalsUV'>fromPositionsNormalsUV</a><br>Creates a new mesh buffer with the given array of vertex positions,
vertex normals, and texture coordinates.<li><a href='#MeshBuffer.fromPositionsUV'>fromPositionsUV</a><br>Creates a new mesh buffer with the given array of vertex positions
and texture coordinates.<li><a href='#MeshBuffer_getPositions'>getPositions</a><br>Gets an array of vertex positions held by this mesh buffer,
arranged by primitive.<li><a href='#MeshBuffer_primitiveCount'>primitiveCount</a><br>Gets the number of primitives (triangles, lines,
and points) composed by all shapes in this mesh.</ul><a name='MeshBuffer.LINES'></a>
<h3> MeshBuffer.LINES (constant)

</h3>Indicates that a mesh buffer contains line segments; the mesh
buffer stores each line segment using two consecutive vertices.

<p>Default Value: <code>1</code></p><a name='MeshBuffer.POINTS'></a>
<h3> MeshBuffer.POINTS (constant)

</h3>Indicates that a mesh buffer contains points; the mesh
buffer stores each point using one vertex.

<p>Default Value: <code>0</code></p><a name='MeshBuffer.TRIANGLES'></a>
<h3> MeshBuffer.TRIANGLES (constant)

</h3>Indicates that a mesh buffer contains triangles; the mesh
buffer stores each triangle using three consecutive vertices.

<p>Default Value: <code>4</code></p><a name='MeshBuffer.fromPositions'></a>
<h3> (static) MeshBuffer.fromPositions(vertices, [indices])</h3>Creates a new mesh buffer with the given array of vertex positions.<h4> Parameters</h4><ul><li><code>vertices</code> (Type: Array.&lt;number> | Float32Array)<br>An array of vertex positions. This array's length must be divisible by 3; every 3 elements are the X, Y, and Z coordinates, in that order, of one vertex.<li><code>indices</code> (Type: Array.&lt;number> | Uint16Array | Uint32Array | Uint8Array | null | undefined) (optional)<br>Array of vertex indices that the mesh buffer will use. Each index (n) is a number referring to the (n+1)th vertex. If you are defining a set of triangles, there should be 3 indices for each triangle; for line segments, 2 indices for each segment; and for points, 1 index for each point. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.</ul><h4> Return Value</h4>A new mesh buffer. (Type: <a href="MeshBuffer.html">MeshBuffer</a>)<h4> Examples</h4><p>The following example shows how to define a mesh
buffer from a predefined array of vertex positions.</p><pre>
// First, create an array of numbers giving the X, Y, and
// Z coordinate for each vertex position. Here, three vertices
// are defined.
var vertices = [x1, y1, z1, x2, y2, z2, x3, y3, z3 ];
// Second -- and this is optional -- create a second array of numbers
// giving the indices to vertices defined in the previous step.
// Each index refers to the (n+1)th vertex; since 3 vertices
// were defined, the highest index is 2.
var indices = [0, 1, 2];
// Finally, create the mesh buffer. (If there are no indices,
// leave out the "indices" argument.)
var meshBuffer=MeshBuffer.fromPositions(vertices, indices);</pre><p>The following example generates a mesh buffer
consisting of a 10 &times; 10 &times; 3 grid of points. This mesh buffer can serve, for
example, as instance data to draw multiple instances
of a 3-D cube in different positions.</p><pre>
var vertices=[]
for(var x=0;x<10;x++)
for(var y=0;y<10;y++)
for(var z=0;z<10;z++)vertices.push(x,y,z);
var meshBuffer=MeshBuffer.fromPositions(vertices)
.setType(MeshBuffer.POINTS);</pre><a name='MeshBuffer.fromPositionsColors'></a>
<h3> (static) MeshBuffer.fromPositionsColors(vertices, [indices])</h3>Creates a new mesh buffer with the given array of vertex positions
and vertex colors.<h4> Parameters</h4><ul><li><code>vertices</code> (Type: Array.&lt;number> | Float32Array)<br>An array of vertex data. This array's length must be divisible by 6; every 6 elements describe one vertex and are in the following order:<ol> <li>X, Y, and Z coordinates, in that order, of the vertex position. <li>Red, green, and blue components, in that order, of the vertex color, where each component ranges from a low of 0 to a high of 1.</ol><li><code>indices</code> (Type: Array.&lt;number> | Uint16Array | Uint32Array | Uint8Array | null | undefined) (optional)<br>Array of vertex indices that the mesh buffer will use. Each index (n) is a number referring to the (n+1)th vertex. If you are defining a set of triangles, there should be 3 indices for each triangle; for line segments, 2 indices for each segment; and for points, 1 index for each point. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.</ul><h4> Return Value</h4>A new mesh buffer. (Type: <a href="MeshBuffer.html">MeshBuffer</a>)<h4> Examples</h4><p>The following example shows how to define a mesh
buffer from a predefined array of vertex positions, normals,
and texture cordinates.</p><pre>
// First, create an array of numbers giving the X, Y, and
// Z coordinate for each vertex position and associated
// color components. Here, three vertices
// are defined. For each vertex, the position is given, followed by
// the color components.
var vertices = [
x1, y1, z1, r1, g1, b1,
x2, y2, z2, r2, g2, b2,
x3, y3, z3, r3, g3, b3 ];
// Second -- and this is optional -- create a second array of numbers
// giving the indices to vertices defined in the previous step.
// Each index refers to the (n+1)th vertex; since 3 vertices
// were defined, the highest index is 2.
var indices = [0, 1, 2];
// Finally, create the mesh buffer. (If there are no indices,
// leave out the "indices" argument.)
var meshBuffer=MeshBuffer.fromPositionsColors(vertices, indices);</pre><a name='MeshBuffer.fromPositionsNormals'></a>
<h3> (static) MeshBuffer.fromPositionsNormals(vertices, [indices])</h3>Creates a new mesh buffer with the given array of vertex positions
and vertex normals.<h4> Parameters</h4><ul><li><code>vertices</code> (Type: Array.&lt;number> | Float32Array)<br>An array of vertex data. This array's length must be divisible by 6; every 6 elements describe one vertex and are in the following order:<ol> <li>X, Y, and Z coordinates, in that order, of the vertex position. <li>X, Y, and Z components, in that order, of the vertex normal.</ol><li><code>indices</code> (Type: Array.&lt;number> | Uint16Array | Uint32Array | Uint8Array | null | undefined) (optional)<br>Array of vertex indices that the mesh buffer will use. Each index (n) is a number referring to the (n+1)th vertex. If you are defining a set of triangles, there should be 3 indices for each triangle; for line segments, 2 indices for each segment; and for points, 1 index for each point. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.</ul><h4> Return Value</h4>A new mesh buffer. (Type: <a href="MeshBuffer.html">MeshBuffer</a>)<h4> Examples</h4><p>The following example shows how to define a mesh
buffer from a predefined array of vertex positions and normals.</p><pre>
// First, create an array of numbers giving the X, Y, and
// Z coordinate for each vertex position and normal. Here, three vertices
// are defined. For each vertex, the position is given, followed by
// the normal.
var vertices = [
x1, y1, z1, nx1, ny1, nz1,
x2, y2, z2, nx2, ny2, nz2,
x3, y3, z3, nx3, ny3, nz3 ];
// Second -- and this is optional -- create a second array of numbers
// giving the indices to vertices defined in the previous step.
// Each index refers to the (n+1)th vertex; since 3 vertices
// were defined, the highest index is 2.
var indices = [0, 1, 2];
// Finally, create the mesh buffer. (If there are no indices,
// leave out the "indices" argument.)
var meshBuffer=MeshBuffer.fromPositionsNormals(vertices, indices);</pre><a name='MeshBuffer.fromPositionsNormalsColors'></a>
<h3> (static) MeshBuffer.fromPositionsNormalsColors(vertices, [indices])</h3>Creates a new mesh buffer with the given array of vertex positions,
vertex normals, and vertex colors.<h4> Parameters</h4><ul><li><code>vertices</code> (Type: Array.&lt;number> | Float32Array)<br>An array of vertex data. This array's length must be divisible by 9; every 9 elements describe one vertex and are in the following order:<ol> <li>X, Y, and Z coordinates, in that order, of the vertex position. <li>X, Y, and Z components, in that order, of the vertex normal. <li>Red, green, and blue components, in that order, of the vertex color, where each component ranges from a low of 0 to a high of 1.</ol><li><code>indices</code> (Type: Array.&lt;number> | Uint16Array | Uint32Array | Uint8Array | null | undefined) (optional)<br>Array of vertex indices that the mesh buffer will use. Each index (n) is a number referring to the (n+1)th vertex. If you are defining a set of triangles, there should be 3 indices for each triangle; for line segments, 2 indices for each segment; and for points, 1 index for each point. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.</ul><h4> Return Value</h4>A new mesh buffer. (Type: <a href="MeshBuffer.html">MeshBuffer</a>)<h4> Examples</h4><p>The following example shows how to define a mesh
buffer from a predefined array of vertex positions, normals,
and texture cordinates.</p><pre>
// First, create an array of numbers giving the X, Y, and
// Z coordinate for each vertex position and normal, and associated
// color components. Here, three vertices
// are defined. For each vertex, the position is given, followed by
// the normal, followed by the color components.
var vertices = [
x1, y1, z1, nx1, ny1, nz1, r1, g1, b1,
x2, y2, z2, nx2, ny2, nz2, r2, g2, b2,
x3, y3, z3, nx3, ny3, nz3, r3, g3, b3 ];
// Second -- and this is optional -- create a second array of numbers
// giving the indices to vertices defined in the previous step.
// Each index refers to the (n+1)th vertex; since 3 vertices
// were defined, the highest index is 2.
var indices = [0, 1, 2];
// Finally, create the mesh buffer. (If there are no indices,
// leave out the "indices" argument.)
var meshBuffer=MeshBuffer.fromPositionsNormalsColors(vertices, indices);</pre><a name='MeshBuffer.fromPositionsNormalsUV'></a>
<h3> (static) MeshBuffer.fromPositionsNormalsUV(vertices, [indices])</h3>Creates a new mesh buffer with the given array of vertex positions,
vertex normals, and texture coordinates.<h4> Parameters</h4><ul><li><code>vertices</code> (Type: Array.&lt;number> | Float32Array)<br>An array of vertex data. This array's length must be divisible by 8; every 8 elements describe one vertex and are in the following order:<ol> <li>X, Y, and Z coordinates, in that order, of the vertex position. <li>X, Y, and Z components, in that order, of the vertex normal. <li>U and V <a href="Semantic.html#Semantic.TEXCOORD">texture coordinates</a> in that order, of the vertex.</ol><li><code>indices</code> (Type: Array.&lt;number> | Uint16Array | Uint32Array | Uint8Array | null | undefined) (optional)<br>Array of vertex indices that the mesh buffer will use. Each index (n) is a number referring to the (n+1)th vertex. If you are defining a set of triangles, there should be 3 indices for each triangle; for line segments, 2 indices for each segment; and for points, 1 index for each point. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.</ul><h4> Return Value</h4>A new mesh buffer. (Type: <a href="MeshBuffer.html">MeshBuffer</a>)<h4> Examples</h4><p>The following example shows how to define a mesh
buffer from a predefined array of vertex positions, normals,
and texture cordinates.</p><pre>
// First, create an array of numbers giving the X, Y, and
// Z coordinate for each vertex position and normal, and associated
// texture coordinates. Here, three vertices
// are defined. For each vertex, the position is given, followed by
// the normal, followed by the texture coordinates.
var vertices = [
x1, y1, z1, nx1, ny1, nz1, u1, v1,
x2, y2, z2, nx2, ny2, nz2, u2, v2,
x3, y3, z3, nx3, ny3, nz3, u3, v3 ];
// Second -- and this is optional -- create a second array of numbers
// giving the indices to vertices defined in the previous step.
// Each index refers to the (n+1)th vertex; since 3 vertices
// were defined, the highest index is 2.
var indices = [0, 1, 2];
// Finally, create the mesh buffer. (If there are no indices,
// leave out the "indices" argument.)
var meshBuffer=MeshBuffer.fromPositionsNormalsUV(vertices, indices);</pre><a name='MeshBuffer.fromPositionsUV'></a>
<h3> (static) MeshBuffer.fromPositionsUV(vertices, [indices])</h3>Creates a new mesh buffer with the given array of vertex positions
and texture coordinates.<h4> Parameters</h4><ul><li><code>vertices</code> (Type: Array.&lt;number> | Float32Array)<br>An array of vertex data. This array's length must be divisible by 5; every 5 elements describe one vertex and are in the following order:<ol> <li>X, Y, and Z coordinates, in that order, of the vertex position. <li>U and V <a href="Semantic.html#Semantic.TEXCOORD">texture coordinates</a> in that order, of the vertex.</ol><li><code>indices</code> (Type: Array.&lt;number> | Uint16Array | Uint32Array | Uint8Array | null | undefined) (optional)<br>Array of vertex indices that the mesh buffer will use. Each index (n) is a number referring to the (n+1)th vertex. If you are defining a set of triangles, there should be 3 indices for each triangle; for line segments, 2 indices for each segment; and for points, 1 index for each point. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.</ul><h4> Return Value</h4>A new mesh buffer. (Type: <a href="MeshBuffer.html">MeshBuffer</a>)<h4> Examples</h4><p>The following example shows how to define a mesh
buffer from a predefined array of vertex positions, normals,
and texture cordinates.</p><pre>
// First, create an array of numbers giving the X, Y, and
// Z coordinate for each vertex position and associated
// texture coordinates. Here, three vertices
// are defined. For each vertex, the position is given, followed by
// the texture coordinates.
var vertices = [
x1, y1, z1, u1, v1,
x2, y2, z2, u2, v2,
x3, y3, z3, u3, v3 ];
// Second -- and this is optional -- create a second array of numbers
// giving the indices to vertices defined in the previous step.
// Each index refers to the (n+1)th vertex; since 3 vertices
// were defined, the highest index is 2.
var indices = [0, 1, 2];
// Finally, create the mesh buffer. (If there are no indices,
// leave out the "indices" argument.)
var meshBuffer=MeshBuffer.fromPositionsUV(vertices, indices);</pre><a name='MeshBuffer_getPositions'></a>
<h3> MeshBuffer#getPositions()</h3>Gets an array of vertex positions held by this mesh buffer,
arranged by primitive.
Only values with the attribute semantic <code>POSITION_0</code> are returned.<h4> Return Value</h4>An array of primitives,
each of which holds the vertices that make up that primitive.
If this mesh holds triangles, each primitive will contain three
vertices; if lines, two; and if points, one. Each vertex is an array containing that vertex's coordinates (for example, if the attribute holds 3 elements per value, the coordinates are X, Y, and Z coordinates, in that order). (Type: Array.&lt;Array.&lt;number>>)<a name='MeshBuffer_primitiveCount'></a>
<h3> MeshBuffer#primitiveCount()</h3>Gets the number of primitives (triangles, lines,
and points) composed by all shapes in this mesh.<h4> Return Value</h4>Return value. (Type: number)<p><a href='index.html'>Back to documentation index.</a></p></body></html>
