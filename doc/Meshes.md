# Meshes

[Back to documentation index.](index.md)

<a name='Meshes'></a>
### new Meshes()

Contains methods that create meshes
of various geometric shapes and solids, such as cubes, cylinders,
and spheres.

<img src='shapes.png' alt='An assortment of shapes: a red box, a blue sphere, a bright green 2D ring, and an
orange partial ring on the first row; and a yellow 3D ring, a brown cylinder, a dark
green square, and a purple cone on the second row.'/>
<b>What are normals?</b> A normal is a set of numbers (usually three numbers) describing a particular direction. Generally, a normal's direction is perpendicular to a surface's edges, and points up and
away from the surface. For 3D graphics libraries to calculate a mesh buffer's lighting and shading correctly, that mesh buffer must specify normals for all its vertices.

Normals are important in the lighting and shading model. When light hits an object's surface, how brightly the surface will be lit depends on how directly the light points to the surface. It will be lit the most brightly if the light is directly opposite to its normal, and not at all if the light is perpendicular to the normal or in the same direction as the normal.

In general, vertex normals are 3-dimensional
and are defined for a mesh buffer only if it
also contains vertex positions.

<b>What are texture coordinates?</b> If a texture (array of memory units) will be applied to a mesh buffer's geometry, then texture coordinates need to be specified for each vertex in that mesh buffer. In general, a texture coordinate is one of two numbers, called U and V, that map to a specific point in the texture. Each texture coordinate ranges from 0 to 1.

In most 3D graphics pipelines, u-coordinates start at the left of the texture (0) and increase to the right (1). In some graphics pipelines, such as OpenGL, v-coordinates start by default at the bottom of the texture (0) and increase to the top (1), whereas in others, such as WebGL, Vulkan, Metal, and Direct3D, v-coordinates start by default at the top of the texture and increase to the bottom. Thus, for example, in OpenGL by default, texture coordinates (0, 1) indicate the upper-left corner of the texture, and texture coordinates (0.5, 0.5) indicate the center of the texture.

In general, texture coordinates describe 2-dimensional points.
However, for such texturing tasks as mapping
a square to a trapezoid, trios of 3-dimensional texture coordinates (U, V, and Z)
are useful to ensure the texturing remains perspective-correct.
In this case, the 3-D texture coordinates are converted
to 2-D by dividing the U and V components by the Z component.
In a fragment shader or pixel shader, this can look like
the following
code: <code>texCoord.xy/texCoord.z</code>.

### Methods

* [createBox](#Meshes.createBox)<br>Creates a mesh of a box (rectangular prism), which
will be centered at the origin.
* [createBoxEx](#Meshes.createBoxEx)<br>Creates a mesh of a box (rectangular prism) given the box's smallest and largest coordinates.
* [createCapsule](#Meshes.createCapsule)<br>Creates a mesh of a capsule, centered at the origin.
* [createClosedCylinder](#Meshes.createClosedCylinder)<br>Creates a mesh of a closed cylinder or closed cone.
* [createCylinder](#Meshes.createCylinder)<br>Creates a mesh of a cylinder or cone.
* [createDisk](#Meshes.createDisk)<br>Creates a mesh of a 2D circular disk or regular polygon, possibly with a hole in the middle, centered at the origin.
* [createLathe](#Meshes.createLathe)<br>Creates a mesh of a figure generated by revolving a path of 2-dimensional
points about the z-axis.
* [createPartialDisk](#Meshes.createPartialDisk)<br>Creates a mesh of a 2D circular disk or regular polygon or a part of either, possibly with a hole where the middle of the complete disk or polygon would be; the middle of the complete disk or polygon is placed at the origin.
* [createPlane](#Meshes.createPlane)<br>Creates a mesh of a 2D rectangle, centered at the origin.
* [createPointedStar](#Meshes.createPointedStar)<br>Creates a mesh in the form of a two-dimensional n-pointed star.
* [createSphere](#Meshes.createSphere)<br>Creates a mesh of a sphere, centered at the origin.
* [createTorus](#Meshes.createTorus)<br>Creates a mesh of a torus (doughnut shape), centered at the origin.
* [fromPositions](#Meshes.fromPositions)<br>TODO: Not documented yet.
* [fromPositionsAutoNormals](#Meshes.fromPositionsAutoNormals)<br>TODO: Not documented yet.
* [fromPositionsNormals](#Meshes.fromPositionsNormals)<br>TODO: Not documented yet.
* [fromPositionsNormalsUV](#Meshes.fromPositionsNormalsUV)<br>TODO: Not documented yet.
* [lineLoopIndices](#Meshes.lineLoopIndices)<br>Creates an array of vertex indices corresponding to triangles that make up a line loop, a series of vertices that make up a connected line segment path, with the last point also connected to the first.
* [lineStripIndices](#Meshes.lineStripIndices)<br>Creates an array of vertex indices corresponding to triangles that make up a line strip, a series of vertices that make up a connected line segment path.
* [quadStripIndices](#Meshes.quadStripIndices)<br>Creates an array of vertex indices corresponding to triangles that make up a strip of quadrilaterals.
* [quadsIndices](#Meshes.quadsIndices)<br>Creates an array of vertex indices corresponding to triangles that make up a series of quadrilaterals, where every 4 vertices is a separate quadrilateral.
* [triangleFanIndices](#Meshes.triangleFanIndices)<br>Creates an array of vertex indices corresponding to triangles that make up a triangle fan or convex polygon.
* [triangleStripIndices](#Meshes.triangleStripIndices)<br>Creates an array of vertex indices corresponding to triangles that make up a triangle strip.

<a name='Meshes.createBox'></a>
### (static) Meshes.createBox(xSize, ySize, zSize, [inward])

Creates a mesh of a box (rectangular prism), which
will be centered at the origin.
Will create texture coordinates such that the same texture
is used on each face of the box. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner. The resulting mesh buffer
will use 36 vertex indices divided into 12 triangles, with each
face using two triangles. The faces will be ordered as follows:
Negative-x axis-facing face, positive-x axis-facing face, negative-y axis-facing face,
positive-y axis-facing face, negative-z axis-facing face, positive-z axis-facing face.

#### Parameters

* `xSize` (Type: number)<br>Width of the box.
* `ySize` (Type: number)<br>Height of the box.
* `zSize` (Type: number)<br>Depth of the box. If xSize, ySize, and zSize are the same number, the result is a cube.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the box will be viewed from the inside.

#### Return Value

A buffer geometry. The generated mesh. (Type: *)

<a name='Meshes.createBoxEx'></a>
### (static) Meshes.createBoxEx(box, [inward])

Creates a mesh of a box (rectangular prism) given the box's smallest and largest coordinates.
Will create texture coordinates such that the same texture
is used on each face of the box. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner. The resulting mesh buffer
will use 36 vertex indices divided into 12 triangles, with each
face using two triangles. The faces will be ordered as follows:
Negative-x axis-facing face, positive-x axis-facing face, negative-y axis-facing face,
positive-y axis-facing face, negative-z axis-facing face, positive-z axis-facing face.

#### Parameters

* `box` (Type: Array.&lt;number>)<br>An axis-aligned bounding box, which is an array of six values, that bounds the box mesh. The first three values are the smallest x-, y-, and z-coordinates, and the last three values are the largest x-, y-, and z-coordinates. If the dimensions along all three axes are the same, the result is a cube.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the box will be viewed from the inside.

#### Return Value

A buffer geometry. The generated mesh. Throws an error if "box" is null or contains negative dimensions along any of its axes. (Type: *)

#### Examples

The following example creates a wire-frame box of the given corner coordinates (<code>box</code>) and color (<code>color</code>).

    var boxMesh=Meshes.createBoxEx(box)
    .setColor(color).wireFrame()

<a name='Meshes.createCapsule'></a>
### (static) Meshes.createCapsule([radius], [length], [slices], [stacks], [middleStacks], [flat], [inside])

Creates a mesh of a capsule, centered at the origin.
The length of the capsule will run along the z-axis. (If the capsule
has a high length and a very low radius, it will resemble a 3D line
with rounded corners; see the example.)

Will also generate texture coordinates such that the V (vertical)
coordinates start from the bottom of the texture and increase from the negative
to positive z-axis, and the U (horizontal) coordinates start from the left of the
texture and increase from the positive X to positive Y to negative X to negative
Y to positive x-axis. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

If the "length" parameter is 0, the x-, y-, and z-coordinates of a point on the solid
are as described in <a href="Meshes.md#Meshes.createSphere">Meshes.createSphere</a>.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `radius` (Type: number) (optional)<br>Radius of each spherical end of the capsule. May be null, undefined, or omitted, in which case the default is 1.
* `length` (Type: number) (optional)<br>Length of the middle section. May be null, undefined, or omitted, in which case the default is 1. If this value is 0, an approximation to a sphere will be generated.
* `slices` (Type: number) (optional)<br>Number of vertical sections the capsule consists of. This function will create an octahedron if "slices" is 4 and "stacks" is 2. Must be 3 or greater. May be null, undefined, or omitted, in which case the default is 16.
* `stacks` (Type: number) (optional)<br>Number of horizontal sections each spherical half consists of. May be null, undefined, or omitted, in which case the default is 8.
* `middleStacks` (Type: number) (optional)<br>Number of vertical sections the middle of the capsule consists of. May be null, undefined, or omitted, in which case the default is 1.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the capsule will be flat shaded; otherwise, will generate normals such that the capsule will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the capsule will be viewed from the inside.

#### Return Value

A buffer geometry. The generated mesh. (Type: *)

#### Examples

The following method uses <code>createCapsule</code> to create a thin line-like 3D object.

    // point1, point2 - end points of the line
    // thickness - thickness of the line in units, default 1
    function create3DLine(point1,point2,thickness) {
    if(thickness==null)thickness=1
    var vector=MathUtil.vec3sub(point1,point2);
    var dist=MathUtil.vec3length(vector);
    var normVector=MathUtil.vec3norm(vector);
    var midPoint=MathUtil.vec3lerp(point1,point2,0.5);
    var line=Meshes.createCapsule(thickness/2,dist,6,4);
    var matrix=MathUtil.quatToMat4(
    MathUtil.quatFromVectors([0,0,1],normVector));
    matrix[12]=midPoint[0]
    matrix[13]=midPoint[1]
    matrix[14]=midPoint[2]
    return line.transform(matrix);
    }

<a name='Meshes.createClosedCylinder'></a>
### (static) Meshes.createClosedCylinder(baseRad, topRad, height, slices, stacks, [flat], [inside])

Creates a mesh of a closed cylinder or closed cone. The cylinder's base will
be centered at the origin and its height will run along the
positive z-axis. The base and top will be included in the mesh if
their radius is greater than 0. Will generate texture coordinates for
the cylinder and for the base and top.
The base's and top's texture coordinates will be such that the
texture will be flat as seen from either. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

See <a href="Meshes.md#Meshes.createCylinder">Meshes.createCylinder</a> for information on how texture
coordinates for the cylinder (other than the base and top) are generated and how
to find the coordinates of a particular point on the cylinder.

See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `baseRad` (Type: number)<br>Radius of the base of the cylinder. See <a href="Meshes.md#Meshes.createCylinder">Meshes.createCylinder</a>.
* `topRad` (Type: number)<br>Radius of the top of the cylinder. See <a href="Meshes.md#Meshes.createCylinder">Meshes.createCylinder</a>.
* `height` (Type: number)<br>Height of the cylinder.
* `slices` (Type: number)<br>Number of lengthwise "slices" the cylinder consists of. See <a href="Meshes.md#Meshes.createCylinder">Meshes.createCylinder</a>.
* `stacks` (Type: number)<br>Number of vertical stacks the cylinder consists of. May be null, undefined, or omitted, in which case the default is 1.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the cylinder will be flat shaded; otherwise, will generate normals such that the cylinder will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the cylinder will be viewed from the inside.

#### Return Value

A buffer geometry. The generated mesh. (Type: *)

#### Examples

The following method creates a cone that's closed at its base.
<img src="mesh1.png">

    function createClosedCone(radius,height,slices) {
    return Meshes.createClosedCylinder(radius,0,height,slices,1);
    }

<a name='Meshes.createCylinder'></a>
### (static) Meshes.createCylinder(baseRad, topRad, height, [slices], [stacks], [flat], [inside])

Creates a mesh of a cylinder or cone. The cylinder's base will
be centered at the origin and its height will run along the
positive z-axis. The base and top themselves will not be
included in the mesh.

Texture coordinates for the cylinder (other than the base) will
be generated such that the V (vertical)
coordinates start from the bottom of the texture and increase from the origin
to the positive z-axis, and the U (horizontal) coordinates start from the left of the
texture and increase from the positive X to positive Y to negative X to negative
Y to positive x-axis. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

The x-, y-, and z-coordinates of a point on the cylinder are
<code>(-R\*cos(&lambda;), -R\*sin(&lambda;), H\*&phi;)</code>,
where &phi; = <code>(&pi;/2 + L)/&pi;</code>, L is the latitude in radians,
&lambda; is the longitude in radians, H = <code>height</code>,
R = <code>baseRad + (topRad - baseRad) \* &phi;</code>,
and west and south latitudes and
longitudes are negative. (The formula for converting latitude
and longitude is mentioned here because their meaning depends on
exactly how the texture coordinates are generated on the cylinder.
It assumes that in the texture, longitudes range from -180&deg; to 0&deg; to 180&deg; from
left to right, and latitudes range from 90&deg; to 0&deg; to -90&deg; from top to bottom.)

See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `baseRad` (Type: number)<br>Radius of the base of the cylinder. If 0, this function will create an approximation to a downward pointing cone.
* `topRad` (Type: number)<br>Radius of the top of the cylinder. If 0, this function will create an approximation to an upward pointing cone.
* `height` (Type: number)<br>Height of the cylinder.
* `slices` (Type: number) (optional)<br>Number of lengthwise "slices" the cylinder consists of, each slice going through the center of the cylinder. This function will create a triangular prism if "slices" is 3 and both radii are the same; a triangular pyramid if "slices" is 3 and either radius is zero; a rectangular prism if "slices" is 4 and both radii are the same; and a rectangular pyramid if "slices" is 4 and either radius is zero. Must be 3 or greater. May be null, undefined, or omitted, in which case the default is 32.
* `stacks` (Type: number) (optional)<br>Number of vertical stacks the cylinder consists of. May be null, undefined, or omitted, in which case the default is 1.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the cylinder will be flat shaded; otherwise, will generate normals such that the cylinder will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the cylinder will be viewed from the inside.

#### Return Value

A buffer geometry. The generated mesh. (Type: *)

<a name='Meshes.createDisk'></a>
### (static) Meshes.createDisk(inner, outer, [slices], [loops], [inward])

Creates a mesh of a 2D circular disk or regular polygon, possibly with a hole in the middle, centered at the origin.
Assuming the y-axis points up, the x-axis right,
and the z-axis backward from the "eye", the first vertex in the outer edge
of the 2D disk will be at the 12 o'clock position.
Will also generate texture coordinates, assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `inner` (Type: number)<br>Radius of the hole in the middle of the disk. If 0, no hole is created and the method will generate a regular polygon with n sides, where n is the value of "slices". For example, if "inner" is 0 and "slices" is 3, the result will be an equilateral triangle; a square for 4 "slices", a regular pentagon for 5 "slices", and so on.
* `outer` (Type: number)<br>Outer radius of the disk.
* `slices` (Type: number) (optional)<br>Number of slices going around the disk. May be null or omitted; default is 16.
* `loops` (Type: number) (optional)<br>Number of concentric rings the disk makes up. May be null or omitted; default is 1.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point in the opposite direction of the positive z-axis; otherwise, in the same direction of the positive z-axis. Default is false.

#### Return Value

A buffer geometry. The generated mesh. (Type: *)

<a name='Meshes.createLathe'></a>
### (static) Meshes.createLathe(points, [slices], [flat], [inside])

Creates a mesh of a figure generated by revolving a path of 2-dimensional
points about the z-axis.

Texture coordinates will
be generated such that the V (vertical)
coordinates start from the bottom of the texture and increase along the z-axis in the direction
of the given path, and the U (horizontal) coordinates start from the left of the
texture and increase from the positive X to positive Y to negative X to negative
Y to positive x-axis. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

#### Parameters

* `points` (Type: Array.&lt;number>)<br>Array of alternating x- and z-coordinates describing a two-dimensional path that will revolve around the z-axis to generate the figure (the first number is an x-coordinate, the second is a z-coordinate, and so on). Each z-coordinate is a z-coordinate of the point where the path lies, and each x-coordinate is the radius of the figure at that point. The z-coordinates should be given in increasing order and should not be the same from one point to the next. This parameter's length must be 4 or greater and be an even number.
* `slices` (Type: number) (optional)<br>Number of lengthwise "slices" the figure consists of. Must be 3 or greater. May be null or omitted; default is 32.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the figure will be flat shaded; otherwise, will generate normals such that the figure will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the figure will be viewed from the inside.

#### Return Value

A buffer geometry. The generated mesh. (Type: *)

<a name='Meshes.createPartialDisk'></a>
### (static) Meshes.createPartialDisk(inner, outer, [slices], [loops], [start], [sweep], [inward])

Creates a mesh of a 2D circular disk or regular polygon or a part of either, possibly with a hole where the middle of the complete disk or polygon would be; the middle of the complete disk or polygon is placed at the origin.
Will also generate texture coordinates, assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `inner` (Type: number)<br>Radius of the hole where the middle of the complete disk would be. If 0, no hole is created.
* `outer` (Type: number)<br>Outer radius of the disk.
* `slices` (Type: number) (optional)<br>Number of slices going around the partial disk. May be null or omitted; default is 32.
* `loops` (Type: number) (optional)<br>Number of concentric rings the partial disk makes up. May be null or omitted; default is 1.
* `start` (Type: number) (optional)<br>Starting angle of the partial disk, in degrees. May be null or omitted; default is 0. 0 degrees is at the positive y-axis, and 90 degrees at the positive x-axis. Assuming the y-axis points up, the x-axis right, and the z-axis backward from the "eye", 0 degrees is at the 12 o'clock position, and 90 degrees at the 3 o'clock position.
* `sweep` (Type: number) (optional)<br>Arc length of the partial disk, in degrees. May be null or omitted; default is 360. May be negative.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point in the opposite direction of the positive z-axis; otherwise, in the same direction of the positive z-axis. Default is false.

#### Return Value

A buffer geometry. The generated mesh. (Type: *)

<a name='Meshes.createPlane'></a>
### (static) Meshes.createPlane([width], [height], [widthDiv], [heightDiv], [inward])

Creates a mesh of a 2D rectangle, centered at the origin.
The plane's z-coordinate will be 0.
Will also generate texture coordinates that increase toward
the positive x- and y-axes. The texture coordinates will range
from 0 to 1 on each end of the 2D rectangle. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `width` (Type: number) (optional)<br>Width of the rectangle. May be null or omitted; default is 1.
* `height` (Type: number) (optional)<br>Height of the rectangle. May be null or omitted; default is 1.
* `widthDiv` (Type: number) (optional)<br>Number of horizontal subdivisions. May be null or omitted; default is 1.
* `heightDiv` (Type: number) (optional)<br>Number of vertical subdivisions. May be null or omitted; default is 1.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point in the opposite direction of the positive z-axis; otherwise, in the same direction of the positive z-axis. Default is false.

#### Return Value

A buffer geometry. The generated mesh. (Type: *)

<a name='Meshes.createPointedStar'></a>
### (static) Meshes.createPointedStar(points, firstRadius, secondRadius, [inward])

Creates a mesh in the form of a two-dimensional n-pointed star.
Will also generate texture coordinates, assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

#### Parameters

* `points` (Type: number)<br>Number of points in the star. Must be 2 or greater.
* `firstRadius` (Type: number)<br>First radius of the star. Must be 0 or greater; this parameter and secondRadius can't both be 0.
* `secondRadius` (Type: number)<br>Second radius of the star. Must be 0 or greater; this parameter and firstRadius can't both be 0.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point in the opposite direction of the positive z-axis; otherwise, in the same direction of the positive z-axis. Default is false.

#### Return Value

A buffer geometry. The generated mesh. (Type: *)

<a name='Meshes.createSphere'></a>
### (static) Meshes.createSphere([radius], [slices], [stacks], [flat], [inside])

Creates a mesh of a sphere, centered at the origin.

Will also generate texture coordinates such that the V (vertical)
coordinates start from the bottom of the texture and increase from the negative
to positive z-axis, and the U (horizontal) coordinates start from the left of the
texture and increase from the positive X to positive Y to negative X to negative
Y to positive x-axis. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

The x-, y-, and z-coordinates of a point on the sphere are
<code>(-R\*cos(&delta;)\*cos(&lambda;), -R\*cos(&delta;)\*sin(&lambda;), R\*sin(&delta;))</code>,
where &delta; and &lambda; are the latitude and longitude, respectively, in radians, R is the sphere's radius,
and west and south latitudes and
longitudes are negative. (The formula for converting latitude
and longitude is mentioned here because their meaning depends on
exactly how the texture coordinates are generated on the sphere.
It assumes that in the texture, longitudes range from -180&deg; to 0&deg; to 180&deg; from
left to right, and latitudes range from 90&deg; to 0&deg; to -90&deg; from top to bottom.)

See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `radius` (Type: number) (optional)<br>Radius of the sphere. May be null, undefined, or omitted, in which case the default is 1.
* `slices` (Type: number) (optional)<br>Number of vertical sections the sphere consists of. This function will create an octahedron if "slices" is 4 and "stacks" is 2. Must be 3 or greater. May be null, undefined, or omitted, in which case the default is 16.
* `stacks` (Type: number) (optional)<br>Number of horizontal sections the sphere consists of. May be null, undefined, or omitted, in which case the default is 16.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the sphere will be flat shaded; otherwise, will generate normals such that the sphere will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the sphere will be viewed from the inside.

#### Return Value

A buffer geometry. The generated mesh. (Type: *)

<a name='Meshes.createTorus'></a>
### (static) Meshes.createTorus(inner, outer, [lengthwise], [crosswise], [flat], [inward])

Creates a mesh of a torus (doughnut shape), centered at the origin.
Will also generate texture coordinates, assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `inner` (Type: number)<br>Inner radius (thickness) of the torus.
* `outer` (Type: number)<br>Outer radius of the torus (distance from the center to the innermost part of the torus).
* `lengthwise` (Type: number) (optional)<br>Number of lengthwise subdivisions. May be null or omitted; default is 16.
* `crosswise` (Type: number) (optional)<br>Number of crosswise subdivisions. May be null or omitted; default is 16.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the torus will be flat shaded; otherwise, will generate normals such that it will be smooth shaded.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Default is false.

#### Return Value

A buffer geometry. The generated mesh. (Type: *)

<a name='Meshes.fromPositions'></a>
### (static) Meshes.fromPositions(three, vertices, [indices])

TODO: Not documented yet.

#### Parameters

* `three` (Type: *)<br>TODO: Not documented yet.
* `vertices` (Type: Array.&lt;number>)<br>TODO: Not documented yet.
* `indices` (Type: Array.&lt;number>) (optional)<br>TODO: Not documented yet.

#### Return Value

A buffer geometry. TODO: Not documented yet. (Type: *)

<a name='Meshes.fromPositionsAutoNormals'></a>
### (static) Meshes.fromPositionsAutoNormals(three, vertices, indices)

TODO: Not documented yet.

#### Parameters

* `three` (Type: *)<br>TODO: Not documented yet.
* `vertices` (Type: Array.&lt;number>)<br>TODO: Not documented yet.
* `indices` (Type: Array.&lt;number>)<br>TODO: Not documented yet.

#### Return Value

TODO: Not documented yet. (Type: *)

<a name='Meshes.fromPositionsNormals'></a>
### (static) Meshes.fromPositionsNormals(three, vertices, indices)

TODO: Not documented yet.

#### Parameters

* `three` (Type: *)<br>TODO: Not documented yet.
* `vertices` (Type: Array.&lt;number>)<br>TODO: Not documented yet.
* `indices` (Type: Array.&lt;number>)<br>TODO: Not documented yet.

#### Return Value

TODO: Not documented yet. (Type: *)

<a name='Meshes.fromPositionsNormalsUV'></a>
### (static) Meshes.fromPositionsNormalsUV(three, vertices, indices)

TODO: Not documented yet.

#### Parameters

* `three` (Type: *)<br>TODO: Not documented yet.
* `vertices` (Type: Array.&lt;number>)<br>TODO: Not documented yet.
* `indices` (Type: Array.&lt;number>)<br>TODO: Not documented yet.

#### Return Value

TODO: Not documented yet. (Type: *)

<a name='Meshes.lineLoopIndices'></a>
### (static) Meshes.lineLoopIndices(vertexCount)

Creates an array of vertex indices corresponding to triangles that make up a line loop, a series of vertices that make up a connected line segment path, with the last point also connected to the first.

#### Parameters

* `vertexCount` (Type: number)<br>Number of vertices that make up the line loop.

#### Return Value

Array of vertex indices corresponding to line segments that make up the line loop. Every two indices in the array is a separate line segment. Returns an empty array if 'vertexCount' is less than 2. (Type: Array.&lt;number>)

#### Examples

The following example sets appropriate indices for a mesh buffer with vertices ordered in line loop vertex order.

    mesh.setIndices(
    Meshes.lineLoopIndices(mesh.vertexCount())
    .map(x=>mesh.getIndex(x)));

<a name='Meshes.lineStripIndices'></a>
### (static) Meshes.lineStripIndices(vertexCount)

Creates an array of vertex indices corresponding to triangles that make up a line strip, a series of vertices that make up a connected line segment path.

#### Parameters

* `vertexCount` (Type: number)<br>Number of vertices that make up the line loop.

#### Return Value

Array of vertex indices corresponding to line segments that make up the line strip. Every two indices in the array is a separate line segment. Returns an empty array if 'vertexCount' is less than 2. (Type: Array.&lt;number>)

#### Examples

The following example sets appropriate indices for a mesh buffer with vertices ordered in line strip vertex order.

    mesh.setIndices(
    Meshes.lineStripIndices(mesh.vertexCount())
    .map(x=>mesh.getIndex(x)));

<a name='Meshes.quadStripIndices'></a>
### (static) Meshes.quadStripIndices(vertexCount)

Creates an array of vertex indices corresponding to triangles that make up a strip of quadrilaterals. For a quadrilateral strip, the first 4 vertices make up the first quadrilateral, and each additional
quadrilateral is made up of the last 2 vertices of the previous quadrilateral and
2 new vertices.

#### Parameters

* `vertexCount` (Type: number)<br>Number of vertices that make up the quadrilateral strip.

#### Return Value

Array of vertex indices corresponding to triangles that make up the quadrilateral strip. Every three indices in the array is a separate triangle. Returns an empty array if 'vertexCount' is less than 4. If 'vertexCount' is not divisible by 2, the excess vertex is ignored. (Type: Array.&lt;number>)

#### Examples

The following example sets appropriate indices for a mesh buffer with vertices ordered in quadrilateral strip vertex order.

    mesh.setIndices(
    Meshes.quadStripIndices(mesh.vertexCount())
    .map(x=>mesh.getIndex(x)));

<a name='Meshes.quadsIndices'></a>
### (static) Meshes.quadsIndices(vertexCount)

Creates an array of vertex indices corresponding to triangles that make up a series of quadrilaterals, where every 4 vertices is a separate quadrilateral.

#### Parameters

* `vertexCount` (Type: number)<br>Number of vertices that make up the quadrilaterals.

#### Return Value

Array of vertex indices corresponding to triangles that make up the quadrilaterals. Every three indices in the array is a separate triangle. Returns an empty array if 'vertexCount' is less than 4. If 'vertexCount' is not divisible by 4, any excess vertices are ignored. (Type: Array.&lt;number>)

#### Examples

The following example sets appropriate indices for a mesh buffer with vertices ordered in quadrilateral vertex order.

    mesh.setIndices(
    Meshes.quadsIndices(mesh.vertexCount())
    .map(x=>mesh.getIndex(x)));

<a name='Meshes.triangleFanIndices'></a>
### (static) Meshes.triangleFanIndices(vertexCount)

Creates an array of vertex indices corresponding to triangles that make up a triangle fan or convex polygon. For triangle fans and convex polygons, the first 3
vertices make up the first triangle, and each additional
triangle is made up of the last vertex, the first vertex of
the first trangle, and 1 new vertex.

#### Parameters

* `vertexCount` (Type: number)<br>Number of vertices that make up the triangle fan or convex polygon.

#### Return Value

Array of vertex indices corresponding to triangles that make up the triangle fan or convex polygon. Every three indices in the array is a separate triangle. Returns an empty array if 'vertexCount' is less than 3. (Type: Array.&lt;number>)

#### Examples

The following example sets appropriate indices for a mesh buffer with vertices ordered in triangle fan vertex order.

    mesh.setIndices(
    Meshes.triangleFanIndices(mesh.vertexCount())
    .map(x=>mesh.getIndex(x)));

<a name='Meshes.triangleStripIndices'></a>
### (static) Meshes.triangleStripIndices(vertexCount)

Creates an array of vertex indices corresponding to triangles that make up a triangle strip. For a triangle strip, the first 3
vertices make up the first triangle, and each additional
triangle is made up of the last 2 vertices and 1
new vertex.

#### Parameters

* `vertexCount` (Type: number)<br>Number of vertices that make up the triangle strip.

#### Return Value

Array of vertex indices corresponding to triangles that make up the triangle strip. Every three indices in the array is a separate triangle. Returns an empty array if 'vertexCount' is less than 3. (Type: Array.&lt;number>)

#### Examples

The following example sets appropriate indices for a mesh buffer with vertices ordered in triangle strip vertex order.

    mesh.setIndices(
    Meshes.triangleStripIndices(mesh.vertexCount())
    .map(x=>mesh.getIndex(x)));

[Back to documentation index.](index.md)
