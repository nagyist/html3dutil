# H3DU.Meshes

[Back to documentation index.](index.md)

<a name='H3DU.Meshes'></a>
### new H3DU.Meshes()

Contains methods that create meshes
of various geometric shapes and solids, such as cubes, cylinders,
and spheres.

<img src='shapes.png' alt='An assortment of shapes: a red box, a blue sphere, a bright green 2D ring, and an
orange partial ring on the first row; and a yellow 3D ring, a brown cylinder, a dark
green square, and a purple cone on the second row.'/>

### Methods

* [createBox](#H3DU.Meshes.createBox)<br>Creates a mesh of a box (rectangular prism), which
will be centered at the origin.
* [createBoxEx](#H3DU.Meshes.createBoxEx)<br>Creates a mesh of a box (rectangular prism) given the box's smallest and largest coordinates.
* [createCapsule](#H3DU.Meshes.createCapsule)<br>Creates a mesh of a capsule, centered at the origin.
* [createClosedCylinder](#H3DU.Meshes.createClosedCylinder)<br>Creates a mesh of a closed cylinder or closed cone.
* [createCylinder](#H3DU.Meshes.createCylinder)<br>Creates a mesh of a cylinder or cone.
* [createDisk](#H3DU.Meshes.createDisk)<br>Creates a mesh of a 2D circular disk or regular polygon, possibly with a hole in the middle, centered at the origin.
* [createLathe](#H3DU.Meshes.createLathe)<br>Creates a mesh of a figure generated by revolving a path of 2-dimensional
points about the z-axis.
* [createPartialDisk](#H3DU.Meshes.createPartialDisk)<br>Creates a mesh of a 2D circular disk or regular polygon or a part of either, possibly with a hole where the middle of the complete disk or polygon would be; the middle of the complete disk or polygon is placed at the origin.
* [createPlane](#H3DU.Meshes.createPlane)<br>Creates a mesh of a 2D rectangle, centered at the origin.
* [createPointedStar](#H3DU.Meshes.createPointedStar)<br>Creates a mesh in the form of a two-dimensional n-pointed star.
* [createSphere](#H3DU.Meshes.createSphere)<br>Creates a mesh of a sphere, centered at the origin.
* [createTorus](#H3DU.Meshes.createTorus)<br>Creates a mesh of a torus (doughnut shape), centered at the origin.

<a name='H3DU.Meshes.createBox'></a>
### (static) H3DU.Meshes.createBox(xSize, ySize, zSize, [inward])

Creates a mesh of a box (rectangular prism), which
will be centered at the origin.
Will create texture coordinates such that the same texture
is used on each face of the box. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner. The resulting mesh buffer
will use 36 vertex indices divided into 12 triangles, with each
face using two triangles. The faces will be ordered as follows:
Negative-x axis-facing face, positive-x axis-facing face, negative-y axis-facing face,
positive-y axis-facing face, negative-z axis-facing face, positive-z axis-facing face.

#### Parameters

* `xSize` (Type: number)<br>Width of the box.
* `ySize` (Type: number)<br>Height of the box.
* `zSize` (Type: number)<br>Depth of the box. If xSize, ySize, and zSize are the same number, the result is a cube.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the box will be viewed from the inside.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createBoxEx'></a>
### (static) H3DU.Meshes.createBoxEx(box, [inward])

Creates a mesh of a box (rectangular prism) given the box's smallest and largest coordinates.
Will create texture coordinates such that the same texture
is used on each face of the box. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner. The resulting mesh buffer
will use 36 vertex indices divided into 12 triangles, with each
face using two triangles. The faces will be ordered as follows:
Negative-x axis-facing face, positive-x axis-facing face, negative-y axis-facing face,
positive-y axis-facing face, negative-z axis-facing face, positive-z axis-facing face.

#### Parameters

* `box` (Type: Array.&lt;number>)<br>An axis-aligned bounding box, which is an array of six values, that bounds the box mesh. The first three values are the smallest x-, y-, and z-coordinates, and the last three values are the largest x-, y-, and z-coordinates. If the dimensions along all three axes are the same, the result is a cube.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the box will be viewed from the inside.

#### Return Value

The generated mesh. Throws an error if "box" is null or contains negative dimensions along any of its axes. (Type: MeshBuffer)

#### Examples

The following example creates a wire-frame box of the given corner coordinates (<code>box</code>) and color (<code>color</code>).

    var boxMesh=Meshes.createBoxEx(box)
    .setColor(color).wireFrame()

<a name='H3DU.Meshes.createCapsule'></a>
### (static) H3DU.Meshes.createCapsule([radius], [length], [slices], [stacks], [middleStacks], [flat], [inside])

Creates a mesh of a capsule, centered at the origin.
The length of the capsule will run along the z-axis. (If the capsule
has a high length and a very low radius, it will resemble a 3D line
with rounded corners; see the example.)

Will also generate texture coordinates such that the V (vertical)
coordinates start from the bottom of the texture and increase from the negative
to positive z-axis, and the U (horizontal) coordinates start from the left of the
texture and increase from the positive X to positive Y to negative X to negative
Y to positive x-axis. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

If the "length" parameter is 0, the x-, y-, and z-coordinates of a point on the solid
are as described in Meshes.createSphere.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `radius` (Type: number) (optional)<br>Radius of each spherical end of the capsule. May be null, undefined, or omitted, in which case the default is 1.
* `length` (Type: number) (optional)<br>Length of the middle section. May be null, undefined, or omitted, in which case the default is 1. If this value is 0, an approximation to a sphere will be generated.
* `slices` (Type: number) (optional)<br>Number of vertical sections the capsule consists of. This function will create an octahedron if "slices" is 4 and "stacks" is 2. Must be 3 or greater. May be null, undefined, or omitted, in which case the default is 16.
* `stacks` (Type: number) (optional)<br>Number of horizontal sections each spherical half consists of. May be null, undefined, or omitted, in which case the default is 8.
* `middleStacks` (Type: number) (optional)<br>Number of vertical sections the middle of the capsule consists of. May be null, undefined, or omitted, in which case the default is 1.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the capsule will be flat shaded; otherwise, will generate normals such that the capsule will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the capsule will be viewed from the inside.

#### Return Value

The generated mesh. (Type: MeshBuffer)

#### Examples

The following method uses <code>createCapsule</code> to create a thin line-like 3D object.

    // point1, point2 - end points of the line
    // thickness - thickness of the line in units, default 1
    function create3DLine(point1,point2,thickness) {
    if(thickness==null)thickness=1
    var vector=MathUtil.vec3sub(point1,point2);
    var dist=MathUtil.vec3length(vector);
    var normVector=MathUtil.vec3norm(vector);
    var midPoint=MathUtil.vec3lerp(point1,point2,0.5);
    var line=Meshes.createCapsule(thickness/2,dist,6,4);
    var matrix=MathUtil.quatToMat4(
    MathUtil.quatFromVectors([0,0,1],normVector));
    matrix[12]=midPoint[0]
    matrix[13]=midPoint[1]
    matrix[14]=midPoint[2]
    return line.transform(matrix);
    }

<a name='H3DU.Meshes.createClosedCylinder'></a>
### (static) H3DU.Meshes.createClosedCylinder(baseRad, topRad, height, slices, stacks, [flat], [inside])

Creates a mesh of a closed cylinder or closed cone. The cylinder's base will
be centered at the origin and its height will run along the
positive z-axis. The base and top will be included in the mesh if
their radius is greater than 0. Will generate texture coordinates for
the cylinder and for the base and top.
The base's and top's texture coordinates will be such that the
texture will be flat as seen from either. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

See Meshes.createCylinder for information on how texture
coordinates for the cylinder (other than the base and top) are generated and how
to find the coordinates of a particular point on the cylinder.

See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `baseRad` (Type: number)<br>Radius of the base of the cylinder. See Meshes.createCylinder.
* `topRad` (Type: number)<br>Radius of the top of the cylinder. See Meshes.createCylinder.
* `height` (Type: number)<br>Height of the cylinder.
* `slices` (Type: number)<br>Number of lengthwise "slices" the cylinder consists of. See Meshes.createCylinder.
* `stacks` (Type: number)<br>Number of vertical stacks the cylinder consists of. May be null, undefined, or omitted, in which case the default is 1.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the cylinder will be flat shaded; otherwise, will generate normals such that the cylinder will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the cylinder will be viewed from the inside.

#### Return Value

The generated mesh. (Type: MeshBuffer)

#### Examples

The following method creates a cone that's closed at its base.
<img src="mesh1.png">

    function createClosedCone(radius,height,slices) {
    return Meshes.createClosedCylinder(radius,0,height,slices,1);
    }

<a name='H3DU.Meshes.createCylinder'></a>
### (static) H3DU.Meshes.createCylinder(baseRad, topRad, height, [slices], [stacks], [flat], [inside])

Creates a mesh of a cylinder or cone. The cylinder's base will
be centered at the origin and its height will run along the
positive z-axis. The base and top themselves will not be
included in the mesh.

Texture coordinates for the cylinder (other than the base) will
be generated such that the V (vertical)
coordinates start from the bottom of the texture and increase from the origin
to the positive z-axis, and the U (horizontal) coordinates start from the left of the
texture and increase from the positive X to positive Y to negative X to negative
Y to positive x-axis. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

The x-, y-, and z-coordinates of a point on the cylinder are
<code>(-R\*cos(&lambda;), -R\*sin(&lambda;), H\*&phi;)</code>,
where &phi; = <code>(&pi;/2 + L)/&pi;</code>, L is the latitude in radians,
&lambda; is the longitude in radians, H = <code>height</code>,
R = <code>baseRad + (topRad - baseRad) \* &phi;</code>,
and west and south latitudes and
longitudes are negative. (The formula for converting latitude
and longitude is mentioned here because their meaning depends on
exactly how the texture coordinates are generated on the cylinder.
It assumes that in the texture, longitudes range from -180&deg; to 0&deg; to 180&deg; from
left to right, and latitudes range from 90&deg; to 0&deg; to -90&deg; from top to bottom.)

See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `baseRad` (Type: number)<br>Radius of the base of the cylinder. If 0, this function will create an approximation to a downward pointing cone.
* `topRad` (Type: number)<br>Radius of the top of the cylinder. If 0, this function will create an approximation to an upward pointing cone.
* `height` (Type: number)<br>Height of the cylinder.
* `slices` (Type: number) (optional)<br>Number of lengthwise "slices" the cylinder consists of, each slice going through the center of the cylinder. This function will create a triangular prism if "slices" is 3 and both radii are the same; a triangular pyramid if "slices" is 3 and either radius is zero; a rectangular prism if "slices" is 4 and both radii are the same; and a rectangular pyramid if "slices" is 4 and either radius is zero. Must be 3 or greater. May be null, undefined, or omitted, in which case the default is 32.
* `stacks` (Type: number) (optional)<br>Number of vertical stacks the cylinder consists of. May be null, undefined, or omitted, in which case the default is 1.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the cylinder will be flat shaded; otherwise, will generate normals such that the cylinder will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the cylinder will be viewed from the inside.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createDisk'></a>
### (static) H3DU.Meshes.createDisk(inner, outer, [slices], [loops], [inward])

Creates a mesh of a 2D circular disk or regular polygon, possibly with a hole in the middle, centered at the origin.
Assuming the y-axis points up, the x-axis right,
and the z-axis toward the viewer, the first vertex in the outer edge
of the 2D disk will be at the 12 o'clock position.
Will also generate texture coordinates, assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `inner` (Type: number)<br>Radius of the hole in the middle of the disk. If 0, no hole is created and the method will generate a regular polygon with n sides, where n is the value of "slices". For example, if "inner" is 0 and "slices" is 3, the result will be an equilateral triangle; a square for 4 "slices", a regular pentagon for 5 "slices", and so on.
* `outer` (Type: number)<br>Outer radius of the disk.
* `slices` (Type: number) (optional)<br>Number of slices going around the disk. May be null or omitted; default is 16.
* `loops` (Type: number) (optional)<br>Number of concentric rings the disk makes up. May be null or omitted; default is 1.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point in the opposite direction of the positive z-axis; otherwise, in the same direction of the positive z-axis. Default is false.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createLathe'></a>
### (static) H3DU.Meshes.createLathe(points, [slices], [flat], [inside])

Creates a mesh of a figure generated by revolving a path of 2-dimensional
points about the z-axis.

Texture coordinates will
be generated such that the V (vertical)
coordinates start from the bottom of the texture and increase along the z-axis in the direction
of the given path, and the U (horizontal) coordinates start from the left of the
texture and increase from the positive X to positive Y to negative X to negative
Y to positive x-axis. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

#### Parameters

* `points` (Type: Array.&lt;number>)<br>Array of alternating x- and z-coordinates describing a two-dimensional path that will revolve around the z-axis to generate the figure (the first number is an x-coordinate, the second is a z-coordinate, and so on). Each z-coordinate is a z-coordinate of the point where the path lies, and each x-coordinate is the radius of the figure at that point. The z-coordinates should be given in increasing order and should not be the same from one point to the next. This parameter's length must be 4 or greater and be an even number.
* `slices` (Type: number) (optional)<br>Number of lengthwise "slices" the figure consists of. Must be 3 or greater. May be null or omitted; default is 32.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the figure will be flat shaded; otherwise, will generate normals such that the figure will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the figure will be viewed from the inside.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createPartialDisk'></a>
### (static) H3DU.Meshes.createPartialDisk(inner, outer, [slices], [loops], [start], [sweep], [inward])

Creates a mesh of a 2D circular disk or regular polygon or a part of either, possibly with a hole where the middle of the complete disk or polygon would be; the middle of the complete disk or polygon is placed at the origin.
Will also generate texture coordinates, assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `inner` (Type: number)<br>Radius of the hole where the middle of the complete disk would be. If 0, no hole is created.
* `outer` (Type: number)<br>Outer radius of the disk.
* `slices` (Type: number) (optional)<br>Number of slices going around the partial disk. May be null or omitted; default is 32.
* `loops` (Type: number) (optional)<br>Number of concentric rings the partial disk makes up. May be null or omitted; default is 1.
* `start` (Type: number) (optional)<br>Starting angle of the partial disk, in degrees. May be null or omitted; default is 0. 0 degrees is at the positive y-axis, and 90 degrees at the positive x-axis. Assuming the y-axis points up, the x-axis right, and the z-axis toward the viewer, 0 degrees is at the 12 o'clock position, and 90 degrees at the 3 o'clock position.
* `sweep` (Type: number) (optional)<br>Arc length of the partial disk, in degrees. May be null or omitted; default is 360. May be negative.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point in the opposite direction of the positive z-axis; otherwise, in the same direction of the positive z-axis. Default is false.

#### Return Value

The generated mesh. (Type: MeshBuffer)

#### Examples

This method creates a ring or disk striped in two colors.<br/>
<img src='mesh2.png' alt='Image of a disk striped in red and almost-white'/>

    // inner, outer - inner and outer radius of the disk
    // color1, color2 - each a color vector or string specifying
    // one of the two stripe colors
    // sections - number of stripes
    // sectionCount - number of sections per stripe
    function stripedDisk(inner,outer,color1,color2,sections,sectionCount) {
    if(sectionCount==null)sectionCount=4
    var firstColor=true
    var ret=new MeshBuffer()
    var sweep=360.0/sections;
    for(var i=0;i<sections;i++) {
    var angle=360.0*(i*1.0/sections);
    var mesh=Meshes.createPartialDisk(inner,outer,
    sectionCount,1,angle,sweep)
    .setColor(firstColor ? color1 : color2)
    firstColor=!firstColor
    ret.merge(mesh);
    }
    return ret;
    }

<a name='H3DU.Meshes.createPlane'></a>
### (static) H3DU.Meshes.createPlane([width], [height], [widthDiv], [heightDiv], [inward])

Creates a mesh of a 2D rectangle, centered at the origin.
The plane's z-coordinate will be 0.
Will also generate texture coordinates that increase toward
the positive x- and y-axes. The texture coordinates will range
from 0 to 1 on each end of the 2D rectangle. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `width` (Type: number) (optional)<br>Width of the rectangle. May be null or omitted; default is 1.
* `height` (Type: number) (optional)<br>Height of the rectangle. May be null or omitted; default is 1.
* `widthDiv` (Type: number) (optional)<br>Number of horizontal subdivisions. May be null or omitted; default is 1.
* `heightDiv` (Type: number) (optional)<br>Number of vertical subdivisions. May be null or omitted; default is 1.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point in the opposite direction of the positive z-axis; otherwise, in the same direction of the positive z-axis. Default is false.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createPointedStar'></a>
### (static) H3DU.Meshes.createPointedStar(points, firstRadius, secondRadius, [inward])

Creates a mesh in the form of a two-dimensional n-pointed star.
Will also generate texture coordinates, assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

#### Parameters

* `points` (Type: number)<br>Number of points in the star. Must be 2 or greater.
* `firstRadius` (Type: number)<br>First radius of the star. Must be 0 or greater; this parameter and secondRadius can't both be 0.
* `secondRadius` (Type: number)<br>Second radius of the star. Must be 0 or greater; this parameter and firstRadius can't both be 0.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point in the opposite direction of the positive z-axis; otherwise, in the same direction of the positive z-axis. Default is false.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createSphere'></a>
### (static) H3DU.Meshes.createSphere([radius], [slices], [stacks], [flat], [inside])

Creates a mesh of a sphere, centered at the origin.

Will also generate texture coordinates such that the V (vertical)
coordinates start from the bottom of the texture and increase from the negative
to positive z-axis, and the U (horizontal) coordinates start from the left of the
texture and increase from the positive X to positive Y to negative X to negative
Y to positive x-axis. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

The x-, y-, and z-coordinates of a point on the sphere are
<code>(-R\*cos(&delta;)\*cos(&lambda;), -R\*cos(&delta;)\*sin(&lambda;), R\*sin(&delta;))</code>,
where &delta; and &lambda; are the latitude and longitude, respectively, in radians, R is the sphere's radius,
and west and south latitudes and
longitudes are negative. (The formula for converting latitude
and longitude is mentioned here because their meaning depends on
exactly how the texture coordinates are generated on the sphere.
It assumes that in the texture, longitudes range from -180&deg; to 0&deg; to 180&deg; from
left to right, and latitudes range from 90&deg; to 0&deg; to -90&deg; from top to bottom.)

See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `radius` (Type: number) (optional)<br>Radius of the sphere. May be null, undefined, or omitted, in which case the default is 1.
* `slices` (Type: number) (optional)<br>Number of vertical sections the sphere consists of. This function will create an octahedron if "slices" is 4 and "stacks" is 2. Must be 3 or greater. May be null, undefined, or omitted, in which case the default is 16.
* `stacks` (Type: number) (optional)<br>Number of horizontal sections the sphere consists of. May be null, undefined, or omitted, in which case the default is 16.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the sphere will be flat shaded; otherwise, will generate normals such that the sphere will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the sphere will be viewed from the inside.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createTorus'></a>
### (static) H3DU.Meshes.createTorus(inner, outer, [lengthwise], [crosswise], [flat], [inward])

Creates a mesh of a torus (doughnut shape), centered at the origin.
Will also generate texture coordinates, assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `inner` (Type: number)<br>Inner radius (thickness) of the torus.
* `outer` (Type: number)<br>Outer radius of the torus (distance from the center to the innermost part of the torus).
* `lengthwise` (Type: number) (optional)<br>Number of lengthwise subdivisions. May be null or omitted; default is 16.
* `crosswise` (Type: number) (optional)<br>Number of crosswise subdivisions. May be null or omitted; default is 16.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the torus will be flat shaded; otherwise, will generate normals such that it will be smooth shaded.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Default is false.

#### Return Value

The generated mesh. (Type: MeshBuffer)

[Back to documentation index.](index.md)
